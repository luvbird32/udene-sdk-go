import { mockTransactionData } from './mockData';
import { TransactionResponse } from './types';

export const createBaseResponse = () => ({
  data: null,
  error: null,
  count: null,
  status: 200,
  statusText: 'OK',
  then: () => Promise.resolve(mockTransactionData),
  catch: () => Promise.resolve(mockTransactionData),
  finally: () => Promise.resolve(mockTransactionData),
  throwOnError: () => createBaseResponse(),
  limit: () => createBaseResponse(),
  order: () => createBaseResponse(),
  range: () => createBaseResponse(),
  single: () => createBaseResponse(),
  maybeSingle: () => createBaseResponse(),
  select: () => createBaseResponse(),
  textSearch: () => createBaseResponse(),
  match: () => createBaseResponse(),
  eq: () => createBaseResponse(),
  neq: () => createBaseResponse(),
  gt: () => createBaseResponse(),
  gte: () => createBaseResponse(),
  lt: () => createBaseResponse(),
  lte: () => createBaseResponse(),
  like: () => createBaseResponse(),
  ilike: () => createBaseResponse(),
  likeAllOf: () => createBaseResponse(),
  likeAnyOf: () => createBaseResponse(),
  ilikeAllOf: () => createBaseResponse(),
  ilikeAnyOf: () => createBaseResponse(),
  is: () => createBaseResponse(),
  in: () => createBaseResponse(),
  contains: () => createBaseResponse(),
  containedBy: () => createBaseResponse(),
  rangeGt: () => createBaseResponse(),
  rangeGte: () => createBaseResponse(),
  rangeLt: () => createBaseResponse(),
  rangeLte: () => createBaseResponse(),
  rangeAdjacent: () => createBaseResponse(),
  overlaps: () => createBaseResponse(),
  not: () => createBaseResponse(),
  filter: () => createBaseResponse(),
  or: () => createBaseResponse(),
  execute: () => Promise.resolve(createBaseResponse())
});