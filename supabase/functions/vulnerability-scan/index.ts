import { createClient } from 'https://esm.sh/@supabase/supabase-js@2'

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
}

Deno.serve(async (req) => {
  // Handle CORS preflight requests
  if (req.method === 'OPTIONS') {
    return new Response('ok', { headers: corsHeaders })
  }

  try {
    const supabaseClient = createClient(
      Deno.env.get('SUPABASE_URL') ?? '',
      Deno.env.get('SUPABASE_SERVICE_ROLE_KEY') ?? '',
      {
        auth: {
          autoRefreshToken: false,
          persistSession: false,
        },
      }
    )

    // Get auth header
    const authHeader = req.headers.get('Authorization')?.split('Bearer ')[1]
    if (!authHeader) {
      throw new Error('No authorization header')
    }

    // Get user and verify admin status
    const { data: { user }, error: userError } = await supabaseClient.auth.getUser(authHeader)
    if (userError || !user) {
      throw new Error('Invalid user token')
    }

    console.log('Checking admin status for user:', user.id)

    // Get user's profile to check role
    const { data: profile, error: profileError } = await supabaseClient
      .from('profiles')
      .select('role')
      .eq('id', user.id)
      .single()

    if (profileError) {
      console.error('Error fetching profile:', profileError)
      throw new Error('Error verifying admin status')
    }

    if (!profile || profile.role !== 'admin') {
      console.log('Unauthorized access attempt. User role:', profile?.role)
      throw new Error('Unauthorized: Admin access required')
    }

    console.log('Admin access verified, proceeding with scan...')

    // Get request payload
    const { scanType = 'full', services = ['web', 'api'] } = await req.json()

    // Analyze device fingerprints
    const { data: devicePatterns, error: deviceError } = await supabaseClient
      .from('device_fingerprints')
      .select('fingerprint_hash, user_id, browser_info, network_info, hardware_info, risk_score')

    if (deviceError) throw deviceError

    // Analyze user creation patterns
    const { data: userPatterns, error: userError2 } = await supabaseClient
      .from('user_creation_patterns')
      .select('*')

    if (userError2) throw userError2

    // Get email patterns
    const { data: emailPatterns, error: emailError } = await supabaseClient
      .from('email_reputation')
      .select('*')
      .order('risk_score', { ascending: false })

    if (emailError) throw emailError

    // Analyze patterns
    const findings = []
    const severityBreakdown = { low: 0, medium: 0, high: 0, critical: 0 }

    // Group devices by IP
    const devicesByIp = {}
    const devicesByFingerprint = {}

    devicePatterns?.forEach(device => {
      const ip = device.network_info?.ip_address
      if (ip) {
        devicesByIp[ip] = devicesByIp[ip] || []
        devicesByIp[ip].push(device)
      }

      const fingerprint = device.fingerprint_hash
      if (fingerprint) {
        devicesByFingerprint[fingerprint] = devicesByFingerprint[fingerprint] || []
        devicesByFingerprint[fingerprint].push(device)
      }
    })

    // Check for IP address patterns
    Object.entries(devicesByIp).forEach(([ip, devices]) => {
      if (devices.length > 2) {
        findings.push({
          name: "Multiple Accounts from Same IP",
          description: `${devices.length} accounts created from IP ${ip}`,
          severity: devices.length > 5 ? "critical" : "high",
          affected_component: "network",
          details: {
            ip_address: ip,
            account_count: devices.length,
            user_ids: devices.map(d => d.user_id)
          }
        })
        severityBreakdown[devices.length > 5 ? "critical" : "high"]++
      }
    })

    // Check for device fingerprint patterns
    Object.entries(devicesByFingerprint).forEach(([fingerprint, devices]) => {
      if (devices.length > 1) {
        findings.push({
          name: "Multiple Accounts from Same Device",
          description: `${devices.length} accounts using identical device fingerprint`,
          severity: devices.length > 3 ? "critical" : "high",
          affected_component: "device",
          details: {
            fingerprint: fingerprint,
            account_count: devices.length,
            user_ids: devices.map(d => d.user_id)
          }
        })
        severityBreakdown[devices.length > 3 ? "critical" : "high"]++
      }
    })

    // Analyze user creation patterns
    userPatterns?.forEach(pattern => {
      if (pattern.user_count > 2) {
        findings.push({
          name: "Bulk Account Creation",
          description: `Multiple accounts created in rapid succession`,
          severity: pattern.user_count > 5 ? "critical" : "high",
          affected_component: "registration",
          details: {
            ip_address: pattern.ip_address,
            account_count: pattern.user_count,
            time_span: {
              first: pattern.first_creation,
              last: pattern.last_creation
            },
            user_ids: pattern.user_ids
          }
        })
        severityBreakdown[pattern.user_count > 5 ? "critical" : "high"]++
      }
    })

    // Check high-risk email patterns
    emailPatterns?.forEach(pattern => {
      if (pattern.risk_score > 70) {
        findings.push({
          name: "High-Risk Email Pattern",
          description: "Email associated with suspicious activity",
          severity: pattern.risk_score > 90 ? "critical" : "high",
          affected_component: "email",
          details: {
            email: pattern.email,
            risk_score: pattern.risk_score,
            platform_occurrences: pattern.platform_occurrences,
            fraud_flags: pattern.fraud_flags
          }
        })
        severityBreakdown[pattern.risk_score > 90 ? "critical" : "high"]++
      }
    })

    // Create scan record
    const { data: scan, error: scanError } = await supabaseClient
      .from('vulnerability_scans')
      .insert({
        user_id: user.id,
        scan_type: scanType,
        status: 'completed',
        total_vulnerabilities: findings.length,
        severity_breakdown: severityBreakdown,
        findings: findings,
        account_correlation: {
          ip_clusters: Object.keys(devicesByIp).length,
          device_clusters: Object.keys(devicesByFingerprint).length,
          duplicate_accounts: findings.filter(f => f.affected_component === 'registration').length
        }
      })
      .select()
      .single()

    if (scanError) throw scanError

    console.log('Security pattern analysis completed:', {
      total_findings: findings.length,
      severity_breakdown: severityBreakdown
    })

    return new Response(
      JSON.stringify({
        scan_id: scan.id,
        findings,
        severity_breakdown: severityBreakdown,
        total_vulnerabilities: findings.length,
        scan_timestamp: new Date().toISOString()
      }),
      {
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
        status: 200,
      },
    )

  } catch (error) {
    console.error('Error in vulnerability scan:', error)
    return new Response(
      JSON.stringify({
        error: error.message,
        details: error
      }),
      {
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
        status: 400,
      },
    )
  }
})